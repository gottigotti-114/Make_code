javaの動かし方
    javaのコンパイル方法 「javac ファイル名.java」　※このときできるclassファイルはC言語でいうexeファイルのようなもの
    javaの実行方法「java ファイル名.java」

命名の仕方
    クラス名→先頭を大文字にする
    変数名→基本的には小文字。使えるのはアルファベット、数字、$
    {書き方の例}
    age     数字で始まる名前はダメ
    myAge   (2つめの単語の先頭は大文字)
    my-age

データ型
    整数    byte
                short
                int
                long
    少数    float
                double
    文字    char
    文字列 String   ※Sは大文字

float型の規定
    float weight;
    weight = 57.5F;     このFとはFと書かなかったらdoubleが主流なので自動的にdouble型になってしまうのでFで指定してfloat型にする

boolean型の使い方
    boolean型はtrueかfalseが入る

リテラルの型について
    '〇'でシングルクォーテーションで囲ったら文字コードという意味になる -->char
    "○○"でダブルクォーテーションで囲ったら文字列という意味になる -->String
    "○○F"で語尾にFをつければfloat型になる -->float
    "○○L"で語尾にLをつければlong型になる -->long

再代入とは
    int age;
    age =1;
    age = 4;    このように変数を書き換えることを再代入という

定数の作り方
    定数という二度と書き換えることのできない変数を作ることができる
    final int age = 1;  （finalが定数を宣言するためのカギ）

public class MainのMainについて
    javaのpublic class Main{}とあるが、このMainはファイル名の拡張子を取ったものを命名しないといけない
    つまりファイル名がMain1_1.javaだったらpublic class Main1_1{}となる

リテラルとは
    プログラム中に記述する具体的な値のこと
    long a = 20000L;
    とすると、20000Lがリテラルとなる
    long型のリテラルは末尾にlongのLをつけないと区別されず、自動的にintとなる
    float b = 3.14Fとしないと自動的にdoubleになる

    String型のリテラルはダブルクォーテーションで囲まないといけない

    つまり
    変数の型 == リテラルの型
    で同じでないと後にコンパイルエラーとなる


エスケープシーケンスについて
    文字列の最中にダブルクォーテーションを入れる場合は\"(円サインダブルクォート)を入れたらいける


複合代入演算（評価などについて）は
    複合代入演算子(例：a += a)C言語と一緒
    評価とは2 +5 = 7 の+で右と左のオペランド情報を評価して演算という感じで評価という


インクリメントデクリメントについて
    a++;は一番遅くインクリメントされる  -->「　　a=1; 　a++ + 10 = 11　　」   ※計算後の結果に+1インクリメントする
    ++b;は一番早くインクリメントされる --> 「　　b=1;　 ++b + 10 = 12　　」　※計算中に+1インクリメント

テキストブロックの記述方法について
    """ と """で囲んだ文字列でインデントしたら自動的に\nが入っ多文字列が変数に代入される
    "○○\n" + 
    "○○";も+をつけたら改行されたテキストブロックが変数に代入される

データ型の自動変換について
    小さいデータ型は自動で大きいデータ型に変換される
    例：double ← floatはOK
            long ← intはOK
            float ← doubleは場合によってコンパイルエラーになる

    データ型の強制変換について
    int a = (int)2.5　とすれば強制的に2になる

リテラルの強制変換
    double d = 8.5 / 2;     は2が自動的に2.0に代わる
    long l = 5 + 2L;          は5が自動的に5Lに代わる

現在出てきている関数まとめ
    section2
        math.max(a,b)   aとbを比較して大きい方の値を返す
        Integer.parseInt(a)     aが文字列とかだったら数値(int型)にして返す
        new java.util.Random().nextInt(90); 0から89までの乱数を返す
        new java.util.Random().nextInt(7) + 3とすれば3 ~ 9までの乱数を返すことができる
        new java.util.Scanner(System.in).nextLine   文字列をターミナルから入力できる
        new java.util.Scanner(System.in).nextInt    数値をターミナルから入力できる
    
    section3
        変数.equals("○○")   変数が○○と同じだったらtrueを返す。if分などで使われる

switch文まとめ
switch文には二つの書き方がある
新たな書き方
    switch(変数){
        case1,2 -> {
            System.out.println("１と２です");
        }
    }
伝統的な書き方
    swtich(変数){
        case 1,2:
        System.out.println("１と２です");
        break;
    }

式としての利用
	String s = switch(hensu){
		case 1 -> "大吉";	>>hensuが1だった場合に、sに"大吉"が代入される
	}

繰り返し構文
	***　while文　***>> 条件によっては一回もブロック内の処理が実行されない

	while(条件式) {
		条件が真のときに実行する処理
	}
	-------------------------------------------------------------------------
	***　do文　***>> 少なくともブロック内の処理が必ず一回は実行される	

	do {				
		繰り返したい処理
	}while(条件式)
	-------------------------------------------------------------------------
	***　for文　***>> while文の定義を簡潔にしたもの
			　少なくとも一回はブロック内の処理を実行する

	for(int i = 0; i < 10; i++){
		繰り返したい処理
	}

	break文	→　繰り返しのブロックを抜ける
	continue文　→　繰り返しの処理をスキップし次の繰り返しへ進む

配列とその宣言の仕方
    インデックスを添え字と呼ぶ
    定義方法
     (配列の生成)       データ型[ ]  配列変数名;
     (配列の初期化)   配列変数名 = new データ型[要素数];
    END
    定義方法(実技)
    int[] data;
    data = new int[5];

    一気に定義する方法
    int data[] = new int[5];

    配列は自動で初期化してくれる
    数値型→０
    boolean型→false
    オブジェクト型→null

    配列の長さを取り出すには？
    配列名.length

javaの実行時エラー(例外)について
    エラー時の意味
    | java.lang  |.Array|Index  |OutOf|Bounds|Exception
    |パッケージ名|配列  |添え字|外       |範囲     |例外