while文
　条件が正しい間だけループを行う

```
　　while 条件
　　　処理
　　end
```

　何回ループしても処理が終わらない「無限ループ」に
　注意が必要。rubyの場合　ctrlキー + cキー　で強制終了

使う繰り返し構文について

　whileとtimes等、どちらを使うか迷ったときは
　繰り返す回数が分かっているかで考える。

　　10回繰り返す　　…　times
    〇〇以下の間等　…　while

後判定のwhile文
　通常のwhile文は条件を満たさないときは、ループの中は一度も実行されない。

    a = 10
    while a < 10
	puts "こんにちわ"
    end

  ループの中を一度は実行したいときは、後判定のwhileを使う

    a = 10
    
    begin
      puts "こんにちわ"
    end while a < 10

複合代入演算子

　和差積商などの演算子と代入演算子=を組み合わせたもの

　　a += b … aにbを足したものをaに入れる。　a = a + b と同じ
　　a -= b … aからbを引いたものをaに入れる。a = a - b と同じ
　　a *= b … aとbを掛けたものをaに入れる。　a = a * b と同じ
　　a /= b … aをbで割ったものをaに入れる。　a = a / b と同じ
    a %= b … aをbで割ったときの余りをaに入れる。　a = a % b と同じ

開始値から終了値までのループ

　開始値.upto(終了値) do |変数|
    処理
　end

  ※変数には開始値から終了値までが、1ずつ増やえながら入る

練習問題

キーボードから値を入力し、1からその値までの数と、その数分の＊を出力

　値を入力：5
　1:*
　2:**
　3:***
　4:****
　5:*****

配列

　一つの変数の中に複数の値を入れるもの。
　rubyの変数には型がないため、同じ配列の中に文字列型や数値型を混合させて入れることができる。
　
配列の定義
　
  　配列名 = []
  
  宣言と同時に値を入れるには

  　配列名 = [値1,値2,値3,…]

  とする

要素とインデックス

　配列に入っている値のことを要素という
　配列に値を入れると先頭の要素から、0から始まる番号が振られる
　この番号のことをインデックスという

　  配列名 = ["a","b","c"]…aのインデックスは0、bは1、cは2になる

配列に値を代入する

　　配列名[インデックス] = 値

配列の値を参照する

    配列名[インデックス]


p メソッド
　pメソッドはその後に指定された変数などの中身を表示するものになる
　表示する値の型によって出力が変わる

　　数値型
　　　そのまま出力
　　　  例　1

　　文字列型
　　　前後を""で囲んで出力
　　　　例　"abc"

　　配列型
　　　[]で囲んですべての要素を出力
　　　　例  [1,2,3]


nil
  空（から）を表す値。
　c言語ではnull


配列のループ

　配列のループには通常eachメソッドを使う

　　配列名.each do |変数|
      処理
    end
　
　　変数には、先頭から要素が代入され、全ての要素を取り出したら
　　ループが終わる

文字列型
　
　文字列を表すための型。
　文字列にする部分を、"（ダブルクォート）または'（シングルクォート）で囲む必要がある。

　例
    "ABC"
　　'ABC'

エスケープシーケンス

　\（バックスラッシュ）と英字で表される特殊な文字
　Windowsの場合、￥になるときもある。
　
　　主なエスケープシーケンス
        \t　…　水平タブ	/" … "
        \n　…　改行		/' … '
        \\　…　\

式展開
　文字列の中に変数や計算式を埋め込むもの
　文字列の中に#{変数}で表す

　例
　　tanka = 100
      price = 3
      puts "単価#{tanka}円のものを#{price}個買うと#{tanka * price}円"

      単価100円のものを3個買うと300円と表示される

”と'の違い
　文字列は"か'で囲む必要があるが、どちらで囲むかによって動作に違いがある。
　　・エスケープシーケンスが一部しか使えない。（\\と\'だけ使える）
　　・式展開が出来ない

ヒアドキュメント
　改行を含んだ文字列を設定するもの。
　入力されている文字列がそのまま文字列になる。
　<<終了文字列の次の行から行頭にある終了文字列で囲む

　　<<EOS
　　　a
　　　ab
　　　abc
　　EOS

　ヒアドキュメントのなかではシングルクォートやダブルクォートはそのまま出力されるが、
　#{}の式展開は実行される。
　は行頭に書く必要があり、その前にはスペースも入れれない。
　終了文字の<<と終了文字の間に-を入れると行頭に書く必要は無くなる。

シンボルクラス
　様々なものの名前を表すクラス。
　プログラムのコード上では文字列、中では数値で動作する
　:シンボル名で表す
　主にハッシュや引数などで利用される。

　　title = :name
    puts title      ->  nameと出力される

論理クラス（Booleanクラス）
　正しい（真、true）か正しくない（偽、false）を表すクラス
nilクラス
　空（から）をあらわすクラス。0や""（長さ0の文字列）とは異なるので注意

trueやfalse、nilのことを擬似変数という。

if文等の真偽判定
　rubyの場合、falseとnil以外は全てtrueになる

a ||= 0の意味
  a ||= 0 は a = a || 0 と同じ意味になる
  aがnilかfalseの時には0を入れるという意味になり、aが初期化されていないときは0を入れ、それ以外のときはaの値をそのまま使うという意味に
　なる。
　rubyの場合、よく使う書き方になる

配列クラス
　一つの変数の中に複数の値が入っているものを配列という
　配列に入っているそれぞれの値を要素といい、要素には0から始まる番号が自動的に振られる。
　この番号のことをインデックスという

配列の宣言
　主に３種類の宣言方法がある

　[]を使う方法
　　配列名 = []
  []を使い、配列の宣言と同時に値を入れる
　　配列名 = [値1,値2,値3,値4,…]
  Array.newを使う
　　配列名 = Array.new　　※配列名 = []と同じ意味


配列を使う理由
　配列は同じ種類や内容のデータをまとめて扱うことに適している。

　　例、
　　　・データの件数の取得
　　　・次のデータのアドレス管理
　　　・引数にして受け渡し

　　等々


要素に値を設定する
　　配列名[インデックス] = 値

要素の値を参照する
　　配列名[インデックス]

配列に要素を追加する
　　配列名 << 値　

rubyの配列について
　　現在の最大インデックスより、大きいインデックスを指定し
　　値を設定すると、指定したインデックスの要素に値が入り、
　　その間の要素にはnilが入る
　　またインデックスにマイナスの値を設定すると、
　　末尾からインデックスが指定できる

%wや%iを使った配列の作成
　　文字列型やシンボル型の配列を作成するとき
　　%を使った指定の方法がある

　　　文字列型の配列
　　　　%w|a b c|     =>    ["a","b","c"]
        ※スペース区切りで文字列型の配列になる
      　
　　　シンボル型の配列
　　　　%i|a b c|     =>    [:a,:b,:c]
        ※スペース区切りでシンボル型の配列になる

　  ｜の他に!や（）や｛｝など、英数字以外だったら何で囲っても良い
　　また式展開やエスケープシーケンスを使うときには、それぞれ大文字
　　にする。
シンボルを使ったハッシュ
　ハッシュのキーは、多くの場合シンボルが利用される
　
　　hash = {:シンボル名 => 値,:シンボル名 => 値,…}

　シンボルを使ったハッシュの場合特別な宣言がある

　　hash = {シンボル名: 値,シンボル名: 値,…}

  上の宣言と下の宣言は同じものになる

## ハッシュのeach
　ハッシュに対してもeach文が使える
　配列のハッシュと異なるのはキー用の変数と値用の変数が必要に
　なること

　　ハッシュ.each do |キー用の変数,値用の変数|
      処理
　　end

　変数を一つしか指定しない場合、変数には[キー,値]の配列で
　値が入る。

## ユーザ定義メソッド
　今まで使用していたputsやprintはシステムが定義しているメソッドになる
　このメソッドをユーザが作成するものをユーザ定義メソッドという。

## ユーザ定義メソッドの作り方

　def メソッド名(引数,引数,…)
　　処理
　end
　　
　※引数は省略可

## ユーザ定義メソッドの呼び出し

　メソッド名(引数,引数,…)

## ユーザ定義メソッドの命名
　アルファベットの小文字ではじめる。
　2文字目からはアルファベット、数字、アンダーバーを使う
　メソッド名を見たら何をするメソッドか分かるようにする

## 戻り値について
　メソッドから呼び出しもとに何らかの値を1つだけ返すことができる。
　この値のことを戻り値という
　メソッド内で
　　return 値
　とすると、指定した値が戻り値になる。
　またrubyの場合、最後に実行したメソッドの値が自動で戻り値になる


## 変数のスコープ
　変数が使用できる範囲を変数のスコープ（有効範囲）という
　　英小文字または_から始まる　…　ローカル変数
　　$から始まる　…　グローバル変数（プログラムの中で共通)
    @から始まる　…　インスタンス変数
　　@@から始まる　…　クラス変数
　　英大文字から始まる　…　定数(一度設定したら書き換えれない変数)
　　　　　　　　　　　　　　但しRubyの場合、警告が出るが変更できる
## オブジェクト指向プログラミングとは
　処理対象を一つのモノ（オブジェクト）として扱い、その集合体で
　一つのシステムを作るという考え方。
　オブジェクトにはオブジェクトが持つ値（フィールド、プロパティ）と　オブジェクトが行う動作（メソッド）がある。
　
　　例、
　　　　車というシステム。
　　　　　車は、タイヤ、エンジン、ハンドル等のオブジェクトの集合体
　　　　　である。
　　
　そのオブジェクトがどのようなプロパティやメソッドを持っているかを
　定義しているのがクラスになる
　クラスはオブジェクトの設計図になる。
　今現在、ほとんどのプログラムはオブジェクト指向で作成されている。

## クラスとインスタンス
　インスタンスはオブジェクトと同じ意味になる。
　明示的にクラスを宣言し、そのクラスからできたものをインスタンス。
　IntegerやStringなど、システムが作成したクラスからできたものを
　オブジェクトということが多い。
　クラスはあくまでもインスタンスの設計図となり、実際にデータや
　動作をすることは少なく、実際にデータを持ったり動作するのは
　インスタンスになる。


## クラスの定義
　クラスは以下のとおり定義を行う

　　class クラス名
      def メソッド名(引数,引数,…)
        処理
      end
      def メソッド名(引数,引数,…)
        処理
      end
    end

　　クラス名は英大文字で始める必要がある。
    プロパティは@変数名になり、全てのメソッドで
　　共通で使用できる。

  クラスの作成例
　　縦と横の長さを入力し、長方形の面積を求めるクラスShikaku
　　
　　　class Shikaku
        def tate(t)
          @tate = t
        end
	def yoko(y)
          @yoko = y
        end
        def menseki
          @tate * @yoko
        end
      end

## インスタンスの作成
　インスタンスは、クラス名.newで作成される
　例えば変数にインスタンスを代入するときは
　　変数 = クラス名.new
  となる。

　作成したインスタンスのメソッドにアクセスするには
　　インスタンス名.メソッド名(引数)
　とする。

　クラス外部からプロパティに直接アクセスする方法は無く、メソッドを
　使いプロパティにアクセスする

問、
　円の面積と円周を求めるクラスを作成
　インスタンスを作成し以下の通り出力
　但し、半径は  キーボードから取得し円周率は3.14、計算式は
　　面積：半径×半径×円周率
　　円周：2×半径×円周率
　とする

  半径：10
  面積：314
  円周：62.8

問、
  キーボードからを3科目の点数を取得
　合計点と平均点を求めるクラスを作成し、以下のように出力
  国語：40
  数学：50
  英語：61
  合計：151
  平均：50.33333333

     
## セッターとゲッター
　インスタンスのインスタンス変数にデータをセットするメソッドを
　セッターまたはライターという
　インスタンスのインスタンス変数からデータを取得するメソッドを
　ゲッターまたはリーダーという。

=を使ったセッター
　インスタンス変数にデータをセットするメソッドは、よく下記のように
　定義される

　　def インスタンス名=(引数)
      インスタンス変数 = 引数
　　end

  こういう風に宣言することで、クラス外からデータをセットする際
　下記のように使うことができる

　　インスタンス名.インスタンス変数名 = 値

　値に入ったデータはメソッドの引数となり、インスタンス変数に
　設定したデータがセットされる 。
　イコールの前後の空白は無視される。

　インスタンス変数名=のセッターメソッドやインスタンス変数と
　同名のゲッターはセッターやゲッターの基本的な命名方法になる

## 復習
問、
  キーボードからを単価と数量を取得
　金額を求めるクラスを作成し、以下のように出力

　例
　　単価：100
　　数量：10
  　100円のものを10個買うと1000円

問、
  キーボードからを何月を入力
　季節を判定するクラスを作成し、以下のように出力
　春（3～5）、夏（6～8）、秋（9～11）、冬（12～2）


　例
　　月：10
  　10月は秋です。

問、
　キーボードから走行距離と走行時間を入力すると平均時速を求める。
　但し、実行には以下のコードを使うこと
　
```ruby
s = Sokudo.new
print "走行距離："
s.kyori = gets.to_i
print "走行時間："
s.jikan = gets.to_i
puts "#{s.kyori}kmを#{s.jikan}時間で走ると平均時速は#{s.jisoku}です"
```

## アクセスメソッド
    インスタンス変数にデータを取得したり、データを設定するメソッドを
    自動で定義してくれるメソッドがある。
    インスタンス変数にアクセスするメソッドのことをアクセサという。

## データを設定するメソッド
    attr_reader :インスタンス変数名 … ゲッターの定義
	attr_writer :インスタンス変数名 … セッターの定義
	attr_accessor :インスタンス変数名 …セッターとゲッターの両方を宣言
    ※インスタンス変数は,で区切ることができる。

## 復習
問

    名前と時間を設定すると挨拶を行うクラス
    3～10：おはようございます　11～18:こんにちわ 19～2:こんばんわ
```Bash
aisatsu = Aisatsu.new
print "名前："
aisatsu.name = gets.chomp
print "時間："
aisatsu.jikan = gets.to_i
puts "#{aisatsu.aisatsu}。#{aisatsu.name}さん" 
```

問

    以下のクラスを作成
    クラス名：Jikyu
    プロパティ：jikyu … 時給
    hour  … 時間
    name  … 名前
    メソッド：kyuyo … 給与

　　〇〇さんは時給〇円で〇時間働き〇円

問
　以下のクラスを作成
　　
　　クラス名：Jikyu
　　　プロパティ：jikyu … 時給
　　　　　　　　　hour  … 時間
　　　　　　　　　yakin … 夜勤の時間
　　　　　　　　　name  … 名前
　　　メソッド：kyuyo … 給与
　　
　　但し夜勤の時給は+100円とする

出力例
　　時給は1000円、時間は10時間、夜勤は5時間の坂根さんの時給

　　　坂根さんは15500円
　　　　　　　　
## initializeメソッド

　インスタンスを作成時に処理を行うメソッド。

　　class Sample
      def initialize
        処理
　　　end
    end
    s = Sample.new   <- ここでinitializeメソッドが実行される

　主にインスタンス変数の初期化等に利用される。
　このようにインスタンスが作成されるときに、自動で実行されるメソッド　を、コンストラクタという。

　initializeメソッドに引数を渡すこともできる
　
```ruby
　　class Sample
      def initialize(引数1,引数2,…)
        処理
　　　end
    end
    s = Sample.new(引数1,引数2,…)
```

## self変数について
　selfは自分自身を表す変数になる。
　基本的には使う機会は少ないが、ローカル変数と同じ名前のメソッドが
   ある場合など、メソッドを呼び出すときに使用される。
```ruby
  class Sample
    def method
      10
    end
    def sample(method)
       print method
    end
  end

  a = Sample.new
  a.sample(100)
```

P94
## 配列を使った値の代入
複数の変数に配列を使って値を代入することができる

```ruby
a,b,c = [1,2,3]
または
arr = [1,2,3]
a,b,c = arr
```
両方とも、aには1、bには2、cには3が代入される

配列の要素が足りない場合
    
    値を順番に入れていって、足りないところにはnilが入る

    
    arr = [1,2]
    a,b,c = arr … aは1、bは2、cはnil


配列の要素が多い場合

    値を順番に入れていって、過分は無視される

    arr = [1,2,3,4]
    a,b,c = arr

＊を使った代入

    1つだけ＊をつけて変数を指定できる。
    その場合、ほかの変数には順番に値を入れて、残りがすべて
    ＊を付けた変数に配列として入る。

```ruby
arr = [1,2,3,4]
a, *b, c = arr  #aは1,bは[2,3],cは4

arr = [1,2,3]
a, *b, c = arr  #aは1,bは[2],cは3

arr = [1,3]
a, *b, c = arr  #aは1,bは[],cは3
```

## UFO比較演算子
### 主に、ソートなどに使われる演算子。

    左辺と右辺を比べて、
    左辺が大きければ－１
    同じだったら０
    右辺が大きければ１
    が返される

```ruby
式１ <=> 式２
```

## 同一性と同値性

    同じ値か同じオブジェクト化のこと
    同一性・・同じオブジェクトか？
    同値性・・同じ値か？

    a = "1"
    b = "1"

    puts "同じ値です if a == b"               <- 同値性のチェック 今回は真
    puts "同じオブジェクトです" if a.equal?(b) <- 同一性のチェック  今回は偽

    ※a.eql?(b)は同値性のチェックのメソッドである

## 条件演算子

    if else文を一行でかく演算子。
    Railsや組み込み系でよく使われる

      条件 ？ 条件が正しい時の処理 : 条件が正しくないときの処理

```ruby
# 偶数か奇数かを求めるプログラム
1.upto(10) do |i|
    puts "#{i}は#{i % 2 == 0 ? '偶数' : '奇数'}です"
end
```

```組み込みを使うのに適したプログラム```
```ruby
a.equal?(b)
"#{i}は#{i % 2 == 0 ? "偶数" : "奇数"}です"
```
のような複数行を一つの行にまとめる技術はRailsなどで重宝される

## 論理演算子を使ったプログラムの実行

```ruby
a ||= b ...
a &&= b ...
```
a ||= bはa = a || bのことである。
ここでaがfalseかnilだった場合、bが次に判定される仕組みになっている
なので、aにfalseかnil以外の値が入っていたらbは判定にかけられない
```ruby
a = nil
b = 3

a ||= b

puts a
```
```Bash```
```bash
3
```
### ||= &&= の活用
    a ||= メソッドは
    (aもしくはメソッド)の返り値ではなく、
    aにnilかfalseが入っていたらメソッドを実行する

    逆に
    a &&= a.to_iは
    a = a && a.to_iでaが未定義ではなかった場合、a.to_iを実行する。この式ではaがnilだった場合判定にかけない仕組みになっており、falseは確定なのでa.to_iを実行しない。

### a ||= b ... aが未定義だったら、aにbを入れる
### a &&= b ... aとbが未定義されていたら、aにbを入れる。

    a && メソッド ... aがnilかFalse以外であれば、メソッドを実行する

    また、&. という演算子がある

      a &. to_i ... aがnil以外だったら、a.to_iを実行する

    この演算子をぼっち演算子

    ビット演算子

## upcaseメソッド

```ruby
str = "sakane"
p str&.upcase
```
```Bash```
```bash
SAKANE
```
大文字にするメソッドがupcase
### 

## 読み込んだら絶対メモリを確保する
```ruby
if false
  str = "sakane"
end
p str
p str&.upcase
```
ここでfalseの場所は絶対falseだから実行されないかと思われるが、実はプログラムを全部読み込むときに一応、strのメモリを確保してあるからstrに格納される

```ruby
if true
  str = 0
end
p str
p str&.upcase
```
ここでupcaseを実行したときInteger型にはupcaseはないですよ。ということでエラーになる。明確な理由としては文字は1バイトであるため、Integer型から大文字を作る理由がないため

## ビット演算子
### 2新数に対して論理和、論理積、排他的論理和を行うメソッド

    & ... 論理積
    | ... 論理和
    ^ ... 排他的論理和
    ~ ... 否定
    << ... 左シフト
    >> ... 右シフト
    